---
title: Base64
date: 2020-05-14 11:39:45
permalink: /pages/base64
article: false
---

::: details å…³äº Base64 ç¼–ç 
Base64 æ˜¯ç½‘ç»œä¸Šæœ€å¸¸è§çš„ç”¨äºä¼ è¾“ 8Bit å­—èŠ‚ç çš„ç¼–ç æ–¹å¼ä¹‹ä¸€ï¼ŒBase64 æ˜¯ä¸€ç§åŸºäº 64 ä¸ªå¯æ‰“å°å­—ç¬¦æ¥è¡¨ç¤ºäºŒè¿›åˆ¶æ•°æ®çš„æ–¹æ³•ã€‚ç”±äº $log_264 = 6$ï¼Œæ‰€ä»¥æ¯ 6 ä¸ªæ¯”ç‰¹ä¸ºä¸€ä¸ªå•å…ƒï¼Œå¯¹åº”æŸä¸ªå¯æ‰“å°å­—ç¬¦ï¼Œ3 ä¸ªå­—èŠ‚ç›¸å½“äº 24 ä¸ªæ¯”ç‰¹ï¼Œå¯¹åº”äº 4 ä¸ª Base64 å•å…ƒï¼Œå³ 3 ä¸ªå­—èŠ‚å¯ç”± 4 ä¸ªå¯æ‰“å°å­—ç¬¦æ¥è¡¨ç¤ºã€‚Base64 åŒ…æ‹¬å­—æ¯ `a-z`ã€`A-Z`ã€æ•°å­— `0-9`ã€ç¬¦å· `+`ã€`/` ä¸€å…± 64 ä¸ªå­—ç¬¦çš„å­—ç¬¦é›†ï¼Œä»»ä½•ç¬¦å·éƒ½å¯ä»¥è½¬æ¢æˆè¿™ä¸ªå­—ç¬¦é›†ä¸­çš„å­—ç¬¦ï¼Œè¿™ä¸ªè½¬æ¢è¿‡ç¨‹å°±å«åš Base64 ç¼–ç ã€‚

Base64 ç¼–ç æ˜¯ä»äºŒè¿›åˆ¶åˆ°å­—ç¬¦çš„è¿‡ç¨‹ï¼Œå¯ç”¨äºåœ¨ HTTP ç¯å¢ƒä¸‹ä¼ é€’è¾ƒé•¿çš„æ ‡è¯†ä¿¡æ¯ã€‚é‡‡ç”¨ Base64 ç¼–ç å…·æœ‰ä¸å¯è¯»æ€§ï¼Œéœ€è¦è§£ç åæ‰èƒ½é˜…è¯»ã€‚
::: right
Base64 [ç»´åŸºç™¾ç§‘](https://wikipedia.org/wiki/Base64)
:::

## Python <Badge text="3.0+"/>

<code-group>
  <code-block title="ä¾èµ–åº“" active>
  ```python
  import base64
  
  
  data = "spiderapi.cn - è™«æœ¯"
  
  result_encoded = base64.b64encode(data.encode("utf-8")).decode("utf-8")
  result_decoded = base64.b64decode(result_encoded).decode("utf-8")
  print("Base64 ç¼–ç å€¼:", result_encoded)  # c3BpZGVyYXBpLmNuIC0g6Jmr5pyv
  print("Base64 è§£ç å€¼:", result_decoded)
  ```
  </code-block>
  
  <code-block title="çº¯æºç ">
  ```python
  # ä¸å€ŸåŠ©å®˜æ–¹æˆ–è€…ç¬¬ä¸‰æ–¹åº“ï¼Œçº¯æºç å®ç°

  def base64_encode(input_string):
      base64_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
      result = ""
      # å°†è¾“å…¥å­—ç¬¦ä¸²è½¬æ¢ä¸ºå­—èŠ‚
      input_bytes = input_string.encode("utf-8")
      for i in range(0, len(input_bytes), 3):
          chunk = input_bytes[i:i + 3]
          # å°†æ¯ä¸ªå­—ç¬¦è½¬æ¢ä¸ºASCIIç 
          chunk_bytes = [byte for byte in chunk]
          # å°†ä¸‰ä¸ªå­—èŠ‚åˆå¹¶ä¸ºä¸€ä¸ª24ä½çš„äºŒè¿›åˆ¶å­—ç¬¦ä¸²
          binary_string = "".join(format(byte, "08b") for byte in chunk_bytes)
  
          # æ ¹æ®éœ€æ±‚åœ¨äºŒè¿›åˆ¶å­—ç¬¦ä¸²æœ«å°¾è¡¥0
          while len(binary_string) % 24 != 0:
              binary_string += "0"
  
          # å°†24ä½çš„äºŒè¿›åˆ¶å­—ç¬¦ä¸²åˆ‡åˆ†ä¸º6ä½çš„å°å—
          six_bit_chunks = [binary_string[j:j + 6] for j in range(0, len(binary_string), 6)]
  
          # å°†æ¯ä¸ª6ä½çš„äºŒè¿›åˆ¶å­—ç¬¦ä¸²è½¬æ¢ä¸ºç›¸åº”çš„Base64å­—ç¬¦
          for six_bit_chunk in six_bit_chunks:
              if len(six_bit_chunk) < 6:
                  six_bit_chunk = six_bit_chunk.ljust(6, '0')
              result += base64_chars[int(six_bit_chunk, 2)]
  
      # å¯¹ä¸è¶³3ä¸ªå­—ç¬¦çš„æƒ…å†µè¿›è¡ŒBase64å¡«å……
      padding = len(input_bytes) % 3
      if padding == 1:
          result += "=="
      elif padding == 2:
          result += "="
  
      return result
  
  
  def base64_decode(encoded_string):
      base64_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
      result = bytearray()
      # å¯¹äºæ¯4ä¸ªBase64å­—ç¬¦ï¼Œå°†å…¶è§£ç ä¸º3ä¸ªåŸå§‹å­—ç¬¦
      for i in range(0, len(encoded_string), 4):
          chunk = encoded_string[i:i + 4]
          # å°†æ¯ä¸ªBase64å­—ç¬¦è½¬æ¢ä¸ºå…¶å¯¹åº”çš„6ä½äºŒè¿›åˆ¶å­—ç¬¦ä¸²
          binary_string = ""
          for char in chunk:
              if char != "=":
                  binary_string += format(base64_chars.index(char), "06b")
  
          # å°†24ä½çš„äºŒè¿›åˆ¶å­—ç¬¦ä¸²åˆ‡åˆ†ä¸º8ä½çš„å­—ç¬¦
          eight_bit_chunks = [binary_string[j:j + 8] for j in range(0, len(binary_string), 8)]
  
          # å°†æ¯ä¸ª8ä½çš„äºŒè¿›åˆ¶å­—ç¬¦ä¸²è½¬æ¢ä¸ºç›¸åº”çš„å­—èŠ‚
          for eight_bit_chunk in eight_bit_chunks:
              result.append(int(eight_bit_chunk, 2))
  
      return result.decode("utf-8")
  
  
  if __name__ == "__main__":
      data = "spiderapi.cn - è™«æœ¯"
  
      result_encoded = base64_encode(data)
      result_decoded = base64_decode(result_encoded)
      print("Base64 ç¼–ç å€¼:", result_encoded)  # c3BpZGVyYXBpLmNuIC0g6Jmr5pyv
      print("Base64 è§£ç å€¼:", result_decoded)
  ```
  </code-block>
</code-group>

## JavaScript <Badge text="Node.js"/> <Badge text="ECMAScript 5.1+"/>

<code-group>
  <code-block title="ä¾èµ–åº“ 1ï¸âƒ£" active>
  ```javascript
  // ä½¿ç”¨å†…ç½®å‡½æ•° btoa å’Œ atob
  // éœ€è¦æ³¨æ„çš„æ˜¯å‡½æ•°ä»…æ”¯æŒç¼–ç  Latin1 å­—ç¬¦é›†ï¼Œæ‰€ä»¥åƒæ±‰å­—è¿™æ ·çš„å­—ç¬¦é›†æ— æ³•ç¼–ç ï¼Œéœ€è¦å°†å­—ç¬¦ä¸²ä½œä¸º URI ç»„ä»¶è¿›è¡Œç¼–ç åå†è¿›è¡Œ Base64 ç¼–ç ã€‚
  
  var dataLatin1 = "spiderapi.cn";
  var dataChinese = "spiderapi.cn - è™«æœ¯";
  
  var resultEncodedLatin1 = btoa(dataLatin1);
  var resultDecodedLatin1 = atob(resultEncodedLatin1);
  
  var resultEncodedChinese = btoa(unescape(encodeURIComponent(dataChinese)));
  var resultDecodedChinese = decodeURIComponent(escape(atob(resultEncodedChinese)));
  
  console.log("Base64 è‹±æ–‡ç¼–ç å€¼:", resultEncodedLatin1)   // c3BpZGVyYXBpLmNu
  console.log("Base64 è‹±æ–‡è§£ç å€¼:", resultDecodedLatin1)
  console.log("Base64 ä¸­æ–‡ç¼–ç å€¼:", resultEncodedChinese)  // c3BpZGVyYXBpLmNuIC0g6Jmr5pyv
  console.log("Base64 ä¸­æ–‡è§£ç å€¼:", resultDecodedChinese)
  ```
  </code-block>

  <code-block title="ä¾èµ–åº“ 2ï¸âƒ£">
  ```javascript
  // Node ç¯å¢ƒå†…ç½®æ–¹æ³•

  var data = "spiderapi.cn - è™«æœ¯";
  
  var resultEncoded = new Buffer.from(data).toString("base64");
  var resultDecoded = new Buffer.from(resultEncoded, "base64").toString();
  
  console.log("Base64 ç¼–ç å€¼:", resultEncoded)  // c3BpZGVyYXBpLmNuIC0g6Jmr5pyv
  console.log("Base64 è§£ç å€¼:", resultDecoded)
  ```
  </code-block>

  <code-block title="ä¾èµ–åº“ 3ï¸âƒ£">
  ```javascript
  // å®‰è£…ä¾èµ– npm install crypto-js

  var CryptoJS = require("crypto-js");

  var data = "spiderapi.cn - è™«æœ¯";
  var resultEncoded = CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(data));
  var resultDecoded = CryptoJS.enc.Base64.parse(resultEncoded).toString(CryptoJS.enc.Utf8);
  
  console.log("Base64 ç¼–ç å€¼:", resultEncoded)  // c3BpZGVyYXBpLmNuIC0g6Jmr5pyv
  console.log("Base64 è§£ç å€¼:", resultDecoded)
  ```
  </code-block>
  
  <code-block title="çº¯æºç  1ï¸âƒ£">
  ```javascript
  // ä¸å€ŸåŠ©å®˜æ–¹æˆ–è€…ç¬¬ä¸‰æ–¹åº“ï¼Œçº¯æºç å®ç°
  
  var CryptoJS = CryptoJS || (function (Math, undefined) {
      var crypto;
      if (typeof window !== 'undefined' && window.crypto) {
          crypto = window.crypto;
      }
      if (typeof self !== 'undefined' && self.crypto) {
          crypto = self.crypto;
      }
      if (typeof globalThis !== 'undefined' && globalThis.crypto) {
          crypto = globalThis.crypto;
      }
      if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
          crypto = window.msCrypto;
      }
      if (!crypto && typeof global !== 'undefined' && global.crypto) {
          crypto = global.crypto;
      }
      if (!crypto && typeof require === 'function') {
          try {
              crypto = require('crypto');
          } catch (err) {}
      }
      var cryptoSecureRandomInt = function () {
          if (crypto) {
              if (typeof crypto.getRandomValues === 'function') {
                  try {
                      return crypto.getRandomValues(new Uint32Array(1))[0];
                  } catch (err) {}
              }
              if (typeof crypto.randomBytes === 'function') {
                  try {
                      return crypto.randomBytes(4).readInt32LE();
                  } catch (err) {}
              }
          }
          throw new Error('Native crypto module could not be used to get secure random number.');
      };
      var create = Object.create || (function () {
          function F() {}
          return function (obj) {
              var subtype;
              F.prototype = obj;
              subtype = new F();
              F.prototype = null;
              return subtype;
          };
      }());
      var C = {};
      var C_lib = C.lib = {};
      var Base = C_lib.Base = (function () {
          return {
              extend: function (overrides) {
                  var subtype = create(this);
                  if (overrides) {
                      subtype.mixIn(overrides);
                  }
                  if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
                      subtype.init = function () {
                          subtype.$super.init.apply(this, arguments);
                      };
                  }
                  subtype.init.prototype = subtype;
                  subtype.$super = this;
                  return subtype;
              }, create: function () {
                  var instance = this.extend();
                  instance.init.apply(instance, arguments);
                  return instance;
              }, init: function () {}, mixIn: function (properties) {
                  for (var propertyName in properties) {
                      if (properties.hasOwnProperty(propertyName)) {
                          this[propertyName] = properties[propertyName];
                      }
                  }
                  if (properties.hasOwnProperty('toString')) {
                      this.toString = properties.toString;
                  }
              }, clone: function () {
                  return this.init.prototype.extend(this);
              }
          };
      }());
      var WordArray = C_lib.WordArray = Base.extend({
          init: function (words, sigBytes) {
              words = this.words = words || [];
              if (sigBytes != undefined) {
                  this.sigBytes = sigBytes;
              } else {
                  this.sigBytes = words.length * 4;
              }
          }, toString: function (encoder) {
              return (encoder || Hex).stringify(this);
          }, concat: function (wordArray) {
              var thisWords = this.words;
              var thatWords = wordArray.words;
              var thisSigBytes = this.sigBytes;
              var thatSigBytes = wordArray.sigBytes;
              this.clamp();
              if (thisSigBytes % 4) {
                  for (var i = 0; i < thatSigBytes; i++) {
                      var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                      thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
                  }
              } else {
                  for (var j = 0; j < thatSigBytes; j += 4) {
                      thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];
                  }
              }
              this.sigBytes += thatSigBytes;
              return this;
          }, clamp: function () {
              var words = this.words;
              var sigBytes = this.sigBytes;
              words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
              words.length = Math.ceil(sigBytes / 4);
          }, clone: function () {
              var clone = Base.clone.call(this);
              clone.words = this.words.slice(0);
              return clone;
          }, random: function (nBytes) {
              var words = [];
              var r = (function (m_w) {
                  var m_w = m_w;
                  var m_z = 0x3ade68b1;
                  var mask = 0xffffffff;
                  return function () {
                      m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
                      m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
                      var result = ((m_z << 0x10) + m_w) & mask;
                      result /= 0x100000000;
                      result += 0.5;
                      return result * (Math.random() > .5 ? 1 : -1);
                  }
              });
              var RANDOM = false, _r;
              try {
                  cryptoSecureRandomInt();
                  RANDOM = true;
              } catch (err) {}
              for (var i = 0, rcache; i < nBytes; i += 4) {
                  if (!RANDOM) {
                      _r = r((rcache || Math.random()) * 0x100000000);
                      rcache = _r() * 0x3ade67b7;
                      words.push((_r() * 0x100000000) | 0);
                      continue;
                  }
                  words.push(cryptoSecureRandomInt());
              }
              return new WordArray.init(words, nBytes);
          }
      });
      var C_enc = C.enc = {};
      var Hex = C_enc.Hex = {
          stringify: function (wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var hexChars = [];
              for (var i = 0; i < sigBytes; i++) {
                  var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                  hexChars.push((bite >>> 4).toString(16));
                  hexChars.push((bite & 0x0f).toString(16));
              }
              return hexChars.join('');
          }, parse: function (hexStr) {
              var hexStrLength = hexStr.length;
              var words = [];
              for (var i = 0; i < hexStrLength; i += 2) {
                  words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
              }
              return new WordArray.init(words, hexStrLength / 2);
          }
      };
      var Latin1 = C_enc.Latin1 = {
          stringify: function (wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var latin1Chars = [];
              for (var i = 0; i < sigBytes; i++) {
                  var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                  latin1Chars.push(String.fromCharCode(bite));
              }
              return latin1Chars.join('');
          }, parse: function (latin1Str) {
              var latin1StrLength = latin1Str.length;
              var words = [];
              for (var i = 0; i < latin1StrLength; i++) {
                  words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
              }
              return new WordArray.init(words, latin1StrLength);
          }
      };
      var Utf8 = C_enc.Utf8 = {
          stringify: function (wordArray) {
              try {
                  return decodeURIComponent(escape(Latin1.stringify(wordArray)));
              } catch (e) {
                  throw new Error('Malformed UTF-8 data');
              }
          }, parse: function (utf8Str) {
              return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
      };
      var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          reset: function () {
              this._data = new WordArray.init();
              this._nDataBytes = 0;
          }, _append: function (data) {
              if (typeof data == 'string') {
                  data = Utf8.parse(data);
              }
              this._data.concat(data);
              this._nDataBytes += data.sigBytes;
          }, _process: function (doFlush) {
              var processedWords;
              var data = this._data;
              var dataWords = data.words;
              var dataSigBytes = data.sigBytes;
              var blockSize = this.blockSize;
              var blockSizeBytes = blockSize * 4;
              var nBlocksReady = dataSigBytes / blockSizeBytes;
              if (doFlush) {
                  nBlocksReady = Math.ceil(nBlocksReady);
              } else {
                  nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
              }
              var nWordsReady = nBlocksReady * blockSize;
              var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);
              if (nWordsReady) {
                  for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                      this._doProcessBlock(dataWords, offset);
                  }
                  processedWords = dataWords.splice(0, nWordsReady);
                  data.sigBytes -= nBytesReady;
              }
              return new WordArray.init(processedWords, nBytesReady);
          }, clone: function () {
              var clone = Base.clone.call(this);
              clone._data = this._data.clone();
              return clone;
          }, _minBufferSize: 0
      });
      var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          init: function (cfg) {
              this.cfg = this.cfg.extend(cfg);
              this.reset();
          }, reset: function () {
              BufferedBlockAlgorithm.reset.call(this);
              this._doReset();
          }, update: function (messageUpdate) {
              this._append(messageUpdate);
              this._process();
              return this;
          }, finalize: function (messageUpdate) {
              if (messageUpdate) {
                  this._append(messageUpdate);
              }
              var hash = this._doFinalize();
              return hash;
          }, blockSize: 512 / 32,
          _createHelper: function (hasher) {
              return function (message, cfg) {
                  return new hasher.init(cfg).finalize(message);
              };
          }, _createHmacHelper: function (hasher) {
              return function (message, key) {
                  return new C_algo.HMAC.init(hasher, key).finalize(message);
              };
          }
      });
      var C_algo = C.algo = {};
      return C;
  }(Math));
  
  (function () {
      var C = CryptoJS;
      var C_lib = C.lib;
      var WordArray = C_lib.WordArray;
      var C_enc = C.enc;
      var Base64 = C_enc.Base64 = {
          stringify: function (wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var map = this._map;
              wordArray.clamp();
              var base64Chars = [];
              for (var i = 0; i < sigBytes; i += 3) {
                  var byte1 = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                  var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
                  var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;
                  var triplet = (byte1 << 16) | (byte2 << 8) | byte3;
                  for (var j = 0;
                       (j < 4) && (i + j * 0.75 < sigBytes); j++) {
                      base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
                  }
              }
              var paddingChar = map.charAt(64);
              if (paddingChar) {
                  while (base64Chars.length % 4) {
                      base64Chars.push(paddingChar);
                  }
              }
              return base64Chars.join('');
          }, parse: function (base64Str) {
              var base64StrLength = base64Str.length;
              var map = this._map;
              var reverseMap = this._reverseMap;
              if (!reverseMap) {
                  reverseMap = this._reverseMap = [];
                  for (var j = 0; j < map.length; j++) {
                      reverseMap[map.charCodeAt(j)] = j;
                  }
              }
              var paddingChar = map.charAt(64);
              if (paddingChar) {
                  var paddingIndex = base64Str.indexOf(paddingChar);
                  if (paddingIndex !== -1) {
                      base64StrLength = paddingIndex;
                  }
              }
              return parseLoop(base64Str, base64StrLength, reverseMap);
          }, _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
      };
      function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i = 0; i < base64StrLength; i++) {
              if (i % 4) {
                  var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
                  var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
                  words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
                  nBytes++;
              }
          }
          return WordArray.create(words, nBytes);
      }
  }());
  
  
  var data = "spiderapi.cn - è™«æœ¯";
  var resultEncoded = CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(data));
  var resultDecoded = CryptoJS.enc.Base64.parse(resultEncoded).toString(CryptoJS.enc.Utf8);
  
  console.log("Base64 ç¼–ç å€¼:", resultEncoded)  // c3BpZGVyYXBpLmNuIC0g6Jmr5pyv
  console.log("Base64 è§£ç å€¼:", resultDecoded)
  ```
  </code-block>

  <code-block title="çº¯æºç  2ï¸âƒ£">
  ```javascript
  // ä¸å€ŸåŠ©å®˜æ–¹æˆ–è€…ç¬¬ä¸‰æ–¹åº“ï¼Œçº¯æºç å®ç°

  var Base64 = {
      _keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  
      encode: function(input) {
          var output = "";
          var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
          var i = 0;
          input = Base64.utf8Encode(input);
          while (i < input.length) {
              chr1 = input.charCodeAt(i++);
              chr2 = input.charCodeAt(i++);
              chr3 = input.charCodeAt(i++);
              enc1 = chr1 >> 2;
              enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
              enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
              enc4 = chr3 & 63;
              if (isNaN(chr2)) {
                  enc3 = enc4 = 64;
              } else if (isNaN(chr3)) {
                  enc4 = 64;
              }
              output += Base64._keyStr.charAt(enc1) + Base64._keyStr.charAt(enc2) +
                  Base64._keyStr.charAt(enc3) + Base64._keyStr.charAt(enc4);
          }
          return output;
      },
  
      decode: function(input) {
          var output = "";
          var chr1, chr2, chr3;
          var enc1, enc2, enc3, enc4;
          var i = 0;
          input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
          while (i < input.length) {
              enc1 = Base64._keyStr.indexOf(input.charAt(i++));
              enc2 = Base64._keyStr.indexOf(input.charAt(i++));
              enc3 = Base64._keyStr.indexOf(input.charAt(i++));
              enc4 = Base64._keyStr.indexOf(input.charAt(i++));
              chr1 = (enc1 << 2) | (enc2 >> 4);
              chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
              chr3 = ((enc3 & 3) << 6) | enc4;
              output += String.fromCharCode(chr1);
              if (enc3 !== 64) {
                  output += String.fromCharCode(chr2);
              }
              if (enc4 !== 64) {
                  output += String.fromCharCode(chr3);
              }
          }
          output = Base64.utf8Decode(output);
          return output;
      },
  
      utf8Encode: function(string) {
          string = string.replace(/\r\n/g, "\n");
          var utfText = "";
          for (var n = 0; n < string.length; n++) {
              var c = string.charCodeAt(n);
              if (c < 128) {
                  utfText += String.fromCharCode(c);
              } else if ((c > 127) && (c < 2048)) {
                  utfText += String.fromCharCode((c >> 6) | 192);
                  utfText += String.fromCharCode((c & 63) | 128);
              } else {
                  utfText += String.fromCharCode((c >> 12) | 224);
                  utfText += String.fromCharCode(((c >> 6) & 63) | 128);
                  utfText += String.fromCharCode((c & 63) | 128);
              }
          }
          return utfText;
      },
  
      utf8Decode: function(utfText) {
          var string = "";
          var i = 0;
          var c, c1, c2;
          while (i < utfText.length) {
              c = utfText.charCodeAt(i);
              if (c < 128) {
                  string += String.fromCharCode(c);
                  i++;
              } else if ((c > 191) && (c < 224)) {
                  c2 = utfText.charCodeAt(i + 1);
                  string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
                  i += 2;
              } else {
                  c2 = utfText.charCodeAt(i + 1);
                  var c3 = utfText.charCodeAt(i + 2);
                  string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
                  i += 3;
              }
          }
          return string;
      }
  };
  
  
  var data = "spiderapi.cn - è™«æœ¯";
  var resultEncoded = Base64.encode(data);
  var resultDecoded = Base64.decode(resultEncoded);
  
  console.log("Base64 ç¼–ç å€¼:", resultEncoded)  // c3BpZGVyYXBpLmNuIC0g6Jmr5pyv
  console.log("Base64 è§£ç å€¼:", resultDecoded)
  ```
  </code-block>
</code-group>

## Golang <Badge text="1.0+"/>

<code-group>
  <code-block title="ä¾èµ–åº“" active>
  ```go
  package main
  
  import (
      "encoding/base64"
      "fmt"
  )
  
  func main() {
      data := "spiderapi.cn - è™«æœ¯"
      
      resultEncoded := base64.StdEncoding.EncodeToString([]byte(data))
      resultDecoded, err := base64.StdEncoding.DecodeString(resultEncoded)
      if err != nil {
          fmt.Println("Base64 decode error:", err)
          return
      }
      fmt.Println("Base64 ç¼–ç å€¼:", resultEncoded) // c3BpZGVyYXBpLmNuIC0g6Jmr5pyv
      fmt.Println("Base64 è§£ç å€¼:", string(resultDecoded))
  }
  ```
  </code-block>

  <code-block title="çº¯æºç ">
  ```go
  // ä¸å€ŸåŠ©å®˜æ–¹æˆ–è€…ç¬¬ä¸‰æ–¹åº“ï¼Œçº¯æºç å®ç°

  package main

  import "fmt"
  
  const (
      base64Table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
  )
  
  func base64Encode(data []byte) []byte {
      var result []byte
      pad := len(data) % 3
      for i := 0; i < len(data); i += 3 {
      threeBytes := (int(data[i]) << 16) | (int(data[i+1]) << 8) | int(data[i+2])
          result = append(result, base64Table[(threeBytes>>18)&0x3F])
          result = append(result, base64Table[(threeBytes>>12)&0x3F])
          result = append(result, base64Table[(threeBytes>>6)&0x3F])
          result = append(result, base64Table[threeBytes&0x3F])
      }
      if pad > 0 {
          result[len(result)-1] = '='
          if pad == 1 {
              result[len(result)-2] = '='
          }
      }
      return result
  }
  
  func base64Decode(input string) ([]byte, error) {
      var result []byte
      pad := 0
      if input[len(input)-1] == '=' {
          pad++
      }
      if input[len(input)-2] == '=' {
          pad++
      }
      for i := 0; i < len(input); i += 4 {
          oneBytes := (index(input[i]) << 18) | (index(input[i+1]) << 12) | (index(input[i+2]) << 6) | index(input[i+3])
          result = append(result, byte((oneBytes>>16)&0xFF))
          result = append(result, byte((oneBytes>>8)&0xFF))
          result = append(result, byte(oneBytes&0xFF))
      }
      return result[:len(result)-pad], nil
  }
  
  func index(char byte) int {
      for i := 0; i < len(base64Table); i++ {
          if base64Table[i] == char {
              return i
          }
      }
      return -1
  }
  
  func main() {
      data := "spiderapi.cn - è™«æœ¯"
    
      resultEncoded := base64Encode([]byte(data))
      resultDecoded, err := base64Decode(string(resultEncoded))
      if err != nil {
        fmt.Println("Base64 decode error:", err)
        return
      }
      fmt.Println("Base64 ç¼–ç å€¼:", string(resultEncoded)) // c3BpZGVyYXBpLmNuIC0g6Jmr5pyv
      fmt.Println("Base64 è§£ç å€¼:", string(resultDecoded))
  }
  ```
  </code-block>
</code-group>

## ä¸»è¦ç‰¹å¾

Base64 æ˜¯æˆ‘ä»¬æœ€å¸¸è§çš„ç¼–ç ï¼Œé™¤æ­¤ä¹‹å¤–ï¼Œå…¶å®è¿˜æœ‰ Base16ã€Base32ã€Base58ã€Base85ã€Base100 ç­‰ï¼ŒBase ç³»åˆ—ä¸»è¦ç‰¹å¾å¦‚ä¸‹ï¼š

- **Base16**ï¼šç»“å°¾æ²¡æœ‰ç­‰å·ï¼Œæ•°å­—è¦å¤šäºå­—æ¯ï¼›
- **Base32**ï¼šå­—æ¯è¦å¤šäºæ•°å­—ï¼Œæ˜æ–‡æ•°é‡è¶…è¿‡10ä¸ªï¼Œç»“å°¾å¯èƒ½ä¼šæœ‰å¾ˆå¤šç­‰å·ï¼›
- **Base58**ï¼šç»“å°¾æ²¡æœ‰ç­‰å·ï¼Œå­—æ¯è¦å¤šäºæ•°å­—ï¼›
- <font color=red>**Base64ï¼šä¸€èˆ¬æƒ…å†µä¸‹ç»“å°¾éƒ½ä¼šæœ‰1ä¸ªæˆ–è€…2ä¸ªç­‰å·ï¼Œæ˜æ–‡å¾ˆå°‘çš„æ—¶å€™å¯èƒ½æ²¡æœ‰ï¼Œç”± `a-zã€A-Zã€0-9ã€+ã€/` ç»„æˆï¼›**</font>
- **Base85**ï¼šç­‰å·ä¸€èˆ¬å‡ºç°åœ¨å­—ç¬¦ä¸²ä¸­é—´ï¼Œå«æœ‰ä¸€äº›å¥‡æ€ªçš„å­—ç¬¦ï¼›
- **Base100**ï¼šå¯†æ–‡ç”± Emoji è¡¨æƒ…ç»„æˆã€‚

ç¤ºä¾‹ï¼š

| ç¼–ç ç±»å‹    | ç¤ºä¾‹ä¸€                        | ç¤ºä¾‹äºŒ                         |
|:--------|:---------------------------| ----------------------------- |
| æ˜æ–‡      | 01234567890                | administrators                |
| Base16  | `3031323334353637383930`   | `61646D696E6973747261746F7273` |
| Base32  | `GAYTEMZUGU3DOOBZGA======` | `MFSG22LONFZXI4TBORXXE4Y=`    |
| Base58  | `cX8j8pvGzppMKVb`          | `BNF5dFLUTN5XwM1yLoF`         |
| Base64  | `MDEyMzQ1Njc4OTA=`         | `YWRtaW5pc3RyYXRvcnM=`        |
| Base85  | `0JP==1c70M3&rY`           | `@:X4hDJ=06Eaa'.EcV`          |
| Base100 | `ğŸ§ğŸ¨ğŸ©ğŸªğŸ«ğŸ¬ğŸ­ğŸ®ğŸ¯ğŸ°ğŸ§`   | `ğŸ‘˜ğŸ‘›ğŸ‘¤ğŸ‘ ğŸ‘¥ğŸ‘ ğŸ‘ªğŸ‘«ğŸ‘©ğŸ‘˜ğŸ‘«ğŸ‘¦ğŸ‘©ğŸ‘ª`|

## åœ¨çº¿å·¥å…·

- [https://base64.us/](https://base64.us/)
- [https://tool.chinaz.com/tools/base64.aspx](https://tool.chinaz.com/tools/base64.aspx)
